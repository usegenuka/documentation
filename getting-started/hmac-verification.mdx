---

title: Verifying HMAC Signature
sidebarTitle: "HMAC Verification"
description: "Before processing any request from Genuka, verify the HMAC signature to ensure authenticity and security."
---



## Why HMAC verification matters

Before performing **any operation** (such as exchanging an authorization code for an access token), your application must verify that the request **really comes from Genuka**.

When Genuka sends the installation callback to your application, the request includes the following parameters:

```
company_id, code, timestamp, hmac, redirect_to
```

The `hmac` parameter is a **cryptographic signature** generated by Genuka. Your application must **recompute this signature** using your `GENUKA_CLIENT_SECRET` and compare it to the one received.

If they **don’t match**, you **must reject the request** — otherwise, your app could be impersonated.

> ⚠️ **Important:**
> If HMAC verification is not implemented or fails, your application will **never be validated or published** in the Genuka App Store.

---

## Example: Validating HMAC in Node.js

Below is a robust example to validate HMAC in a Node.js / Next.js environment. It recreates the signed string exactly, computes the HMAC using your client secret and compares both values using a constant-time comparison.

```javascript
import crypto from "crypto";

export function validateHmac({
  hmac: receivedHmac,
  timestamp,
  companyId,
}) {
  if (!receivedHmac || !timestamp || !companyId) return false;

  // 1. Recreate the exact string used to generate the HMAC on Genuka's side
  const stringToHash = `company_id=${companyId}&timestamp=${timestamp}`;

  // 2. Compute the HMAC using your GENUKA_CLIENT_SECRET
  const secret = process.env.GENUKA_CLIENT_SECRET || "";
  const computedHmac = crypto
    .createHmac("sha256", secret)
    .update(stringToHash)
    .digest("hex");

  // 3. Compare in constant time to avoid timing attacks
  try {
    return crypto.timingSafeEqual(
      Buffer.from(computedHmac, "hex"),
      Buffer.from(receivedHmac, "hex")
    );
  } catch (err) {
    // In case of length mismatch or other errors, return false
    return false;
  }
}
```

---

## Example verification flow

1. Genuka sends an installation callback to your app:

```
/callback?company_id=123&timestamp=1731456700&hmac=abcd1234&code=xyz
```

2. Extract parameters and validate the HMAC before any other processing:

```javascript
// Express / Next.js example
app.get('/callback', async (req, res) => {
  const { company_id, timestamp, hmac, code } = req.query;

  const isValid = validateHmac({
    hmac: String(hmac || ''),
    timestamp: String(timestamp || ''),
    companyId: String(company_id || ''),
  });

  if (!isValid) {
    return res.status(401).json({ error: 'Invalid HMAC. Request not from Genuka.' });
  }

  // HMAC valid — proceed to exchange the code for an access token
  // (call your token exchange logic here)

  res.status(200).send('HMAC validated — proceeding with token exchange');
});
```

---

## Best Practices

* ✅ **Always** verify the HMAC **before any other processing** (e.g., before exchanging the code for a token).
* ✅ **Never** log or expose your `GENUKA_CLIENT_SECRET`.
* ✅ Use constant-time comparison (e.g., `crypto.timingSafeEqual`) to avoid timing attacks.
* ✅ Immediately reject any request with an invalid HMAC and return an appropriate HTTP status (401 or 403).
* ✅ Optionally, validate the `timestamp` to prevent replay attacks (for example, reject requests older than 5 minutes).
* ✅ Record secure logs for failed verifications (without logging secrets or HMAC values) to help debugging.

---

## Summary

| Step | Description                                                               |
| ---- | ------------------------------------------------------------------------- |
| 1    | Receive callback parameters (`company_id`, `timestamp`, `hmac`, `code`)   |
| 2    | Recreate `stringToHash = "company_id={company_id}&timestamp={timestamp}"` |
| 3    | Generate HMAC using `GENUKA_CLIENT_SECRET`                                |
| 4    | Compare with received `hmac` using constant-time comparison               |
| 5    | Reject if invalid, proceed if valid                                       |

> 🔒 Implementing HMAC verification is mandatory to protect your integration and validate your app for the Genuka App Store.
